name: Fiap Cloud Games CI - User API

on:
  push:
    branches: [ 'main']
  pull_request:
    types: [opened, synchronize]

env:
  AWS_REGION: us-east-1
  # TODO: colocar nos Secrets do GitHub Actions
  AWS_ACCOUNT_ID: 478511033947
  ECR_REPOSITORY: fcg-user-api
  EKS_CLUSTER: fcg
  K8S_NAMESPACE: fcg
  HELM_RELEASE_NAME: user-api

jobs:
  build:
    name: Build the solution
    runs-on: ubuntu-latest
    
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Build
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 8.0.x
      - run: |
          dotnet restore
          dotnet build --no-restore --configuration Release
          
      - name: Upload build output
        uses: actions/upload-artifact@v4
        with:
          name: Build Output
          path: |
            ./
  tests:
    name: Run unit tests
    needs: build
    runs-on: ubuntu-latest
    
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
         
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: Build Output
          path: ./build_result
        
      - name: Unit Tests
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 8.0.x
      - run: dotnet test ./build_result/FCGUserApi.sln --logger trx --results-directory "Results"

      - name: Upload test restult
        uses: actions/upload-artifact@v4
        with:
          name: Test Results
          path: "Results"
        if: ${{ always() }}

      - name: Test Report
        uses: dorny/test-reporter@v2
        if: always()
        with:
          name: .NET Tests Report
          path: "**/*.trx"
          reporter: dotnet-trx
          fail-on-error: true

  build-push:
    name: Build and Push Docker Image
    needs: [build, tests]
    # TODO: if: github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Generate Docker metadata
        id: meta
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          IMAGE_TAG="${{ github.sha }}"
          echo "tags=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "latest=$ECR_REGISTRY/$ECR_REPOSITORY:latest" >> $GITHUB_OUTPUT
      
      - name: Build and Push Docker Image
        env:
          IMAGE_TAG: ${{ steps.meta.outputs.tags }}
          IMAGE_LATEST: ${{ steps.meta.outputs.latest }}
        run: |
          echo "Building Docker image..."
          docker build -t $IMAGE_TAG -t $IMAGE_LATEST .
          
          echo "Pushing to ECR..."
          docker push $IMAGE_TAG
          docker push $IMAGE_LATEST
          
          echo "Image pushed successfully"
          echo "Tag: $IMAGE_TAG"
          echo "Latest: $IMAGE_LATEST"

  deploy-eks:
    name: Deploy to EKS
    needs: [build-push]
    # TODO: if: github.event_name == 'push'
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER }}
          kubectl cluster-info
      
      - name: Install eksctl
        run: |
          curl -sLO "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_Linux_amd64.tar.gz"
          tar -xzf eksctl_Linux_amd64.tar.gz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin
          eksctl version
      
      - name: Create/Update IRSA for External Secrets
        run: |
          echo "Checking if IRSA already exists..."
          if kubectl get serviceaccount fcg-user-api-sa -n ${{ env.K8S_NAMESPACE }} &>/dev/null; then
            echo "ServiceAccount already exists, skipping IRSA creation"
            IRSA_EXISTS=true
          else
            echo "Creating IRSA for fcg-user-api-sa..."
            eksctl create iamserviceaccount \
              --cluster=${{ env.EKS_CLUSTER }} \
              --namespace=${{ env.K8S_NAMESPACE }} \
              --name=fcg-user-api-sa \
              --attach-policy-arn=arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:policy/FCGExternalSecretsPolicy \
              --approve \
              --region=${{ env.AWS_REGION }}
            
            echo "IRSA created successfully"
            echo "Waiting 30s for IAM propagation..."
            sleep 30
            IRSA_EXISTS=false
          fi
      
      - name: Install Helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          helm version
      
      - name: Debug - Check chart structure
        run: |
          echo "Listing k8s/ directory:"
          ls -la k8s/
          echo ""
          echo "Templates directory:"
          ls -la k8s/templates/ || echo "templates/ not found"
      
      - name: Wait for SecretStore to be ready
        run: |
          echo "Waiting for SecretStore to become valid..."
          
          # Wait up to 5 minutes for SecretStore to be ready
          for i in {1..30}; do
            STATUS=$(kubectl get secretstore ${{ env.HELM_RELEASE_NAME }}-fcg-user-api-secretstore \
              -n ${{ env.K8S_NAMESPACE }} \
              -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "NotFound")
            
            if [ "$STATUS" = "True" ]; then
              echo "SecretStore is ready!"
              break
            fi
            
            echo "SecretStore status: $STATUS (attempt $i/30)"
            sleep 10
          done
          
          kubectl get secretstore -n ${{ env.K8S_NAMESPACE }}
      
      - name: Deploy to EKS with Helm
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Deploying FCG User API to EKS..."
          
          helm upgrade --install ${{ env.HELM_RELEASE_NAME }} ./k8s \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --create-namespace \
            --set image.tag=$IMAGE_TAG \
            --timeout 10m \
            --debug
          
          echo "Helm deployment completed"
      
      - name: Debug - List all resources created
        run: |
          echo "All resources in namespace:"
          kubectl get all -n ${{ env.K8S_NAMESPACE }}
      
      - name: Debug - Check pod issues
        if: always()
        run: |
          DEPLOYMENT_NAME="${{ env.HELM_RELEASE_NAME }}-fcg-user-api"
          
          echo "Describing deployment:"
          kubectl describe deployment $DEPLOYMENT_NAME -n ${{ env.K8S_NAMESPACE }} || true
          
          echo ""
          echo "Pod status:"
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app.kubernetes.io/name=fcg-user-api || true
          
          echo ""
          echo "Pod logs (if any):"
          kubectl logs -n ${{ env.K8S_NAMESPACE }} -l app.kubernetes.io/name=fcg-user-api --tail=50 || true
          
          echo ""
          echo "Pod events:"
          kubectl get events -n ${{ env.K8S_NAMESPACE }} --sort-by='.lastTimestamp' | tail -20 || true
      
      - name: Wait for External Secrets sync
        run: |
          echo "Waiting for External Secrets to sync..."
          
          kubectl wait --for=condition=Ready \
            externalsecret/${{ env.HELM_RELEASE_NAME }}-fcg-user-api-externalsecret \
            -n ${{ env.K8S_NAMESPACE }} \
            --timeout=120s
          
          echo "External Secrets synced successfully"
      
      - name: Verify Deployment
        run: |
          echo "Verifying deployment rollout..."
          
          # O Helm cria recursos com o padrão: <release-name>-<chart-name>
          # user-api (release) + fcg-user-api (chart) = user-api-fcg-user-api
          DEPLOYMENT_NAME="${{ env.HELM_RELEASE_NAME }}-fcg-user-api"
          
          kubectl rollout status deployment/$DEPLOYMENT_NAME -n ${{ env.K8S_NAMESPACE }} --timeout=5m
          
          echo ""
          echo "Pods:"
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app.kubernetes.io/name=fcg-user-api
          
          echo ""
          echo "External Secrets:"
          kubectl get externalsecret -n ${{ env.K8S_NAMESPACE }}
          
          echo ""
          echo "Ingress:"
          kubectl get ingress -n ${{ env.K8S_NAMESPACE }}
      
      - name: Get ALB URL
        run: |
          echo "Waiting for ALB to be provisioned..."
          sleep 30
          
          # O Ingress também segue o padrão: <release-name>-<chart-name>
          INGRESS_NAME="${{ env.HELM_RELEASE_NAME }}-fcg-user-api"
          
          ALB_URL=$(kubectl get ingress -n ${{ env.K8S_NAMESPACE }} $INGRESS_NAME -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
          
          if [ -z "$ALB_URL" ]; then
            echo "WARNING: ALB still being provisioned. Check status with:"
            echo "  kubectl get ingress -n ${{ env.K8S_NAMESPACE }} -w"
          else
            echo ""
            echo "=========================================="
            echo "DEPLOYMENT SUCCESSFUL"
            echo "=========================================="
            echo "ALB URL: http://$ALB_URL"
            echo "Health Check: http://$ALB_URL/health"
            echo "API Docs: http://$ALB_URL/docs"
            echo "=========================================="
          fi

  # TODO: Descomentar quando for necessário rodar as migrations automaticament
  # Então adicionar migration como dependência: deploy-eks needs: [build-push, migration]
  migration:
    name: Deploy DB (migrations)
    needs: [build, tests]
    environment: production
    if: false  # Desabilitado temporariamente
    runs-on: 
      - self-hosted
      - linux
      - X64
    env:
      RDS_CONNECTION_STRING: ''
  
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}


      - name: Get RDS connection string from Secrets Manager
        id: get-rds-secret
        run: |
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id fcg-api-user-connection-string \
            --query SecretString \
            --output text)
          echo "RDS_CONNECTION_STRING=$SECRET_JSON" >> $GITHUB_ENV
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          
      - name: Add global tools to PATH
        run: echo "$HOME/.dotnet/tools" >> $GITHUB_PATH

      - name: Apply migrations
        env:
          ConnectionStrings__DefaultConnection: ${{ env.RDS_CONNECTION_STRING }}
        run: |
          dotnet ef database update \
            --configuration Release \
            --project src/Adapters/Drivers/FCGUser.Api/FCGUser.Api.csproj \
            --connection "$ConnectionStrings__DefaultConnection"